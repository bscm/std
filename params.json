{"name":"Std","tagline":"Standard Streams Handlers","body":"# std\r\n\r\nStandard Streams Handlers.\r\n\r\n## Using it\r\n\r\n````bash\r\nsource path/to/std/source.bash\r\n\r\nstd_in -q \"Input required\"\r\necho \"${STDIN}\"\r\n````\r\n\r\n## Available functions\r\n\r\n* [std_out][]\r\n* [std_err][]\r\n* [std_in][]\r\n\r\n### std_out\r\n\r\nThe `std_out` function is basicaly a wrapper of `echo` build-in command, but there\r\nare some gotchas you can also use.\r\n\r\n#### Writing on STDOUT\r\n\r\nAs the same of `echo` build-in command, `std_out` function will always write on\r\n*STDOUT*.\r\n\r\n```bash\r\nstd_out \"STDOUT write\"\r\n```\r\n\r\n#### Writing a single line\r\n\r\nThis is the same behavior of `echo`.\r\n\r\n```bash\r\nstd_out\r\n```\r\n\r\n#### Stylizing\r\n\r\nStylize texts on Bash sometimes sucks! You also have to write the escape char and\r\nthen write the style sequence; `std_out` use `-e` option on `echo` build-in\r\ncommand by default, and also will replace values like `[1;31]` by `\\033[1;31m`\r\nwhen you're in a interactive shell.\r\n\r\n```bash\r\nstd_out \"[0;31]S[][0;32]t[][0;33]y[][0;34]l[][1;90]i[][0;103]z[][4;36]i[][0;36]n[][0;42]g[]\"\r\n```\r\n\r\n#### Don't use new line\r\n\r\nAs the same of `echo` you can avoid use the new line at end.\r\n\r\n```bash\r\nstd_out -n \"No new line\"\r\n```\r\n\r\n#### Don't escape\r\n\r\nIn that part `std_out` is exactly the opposite of `echo` build-in command. By\r\ndefault, `echo` does not escape special chars and `std_out` does, but you also\r\ncan avoid this behavior if you want.\r\n\r\n```bash\r\nstd_out -e \"\\nDo not escape line\"\r\n```\r\n\r\n### std_err\r\n\r\nWith `std_err` you can use all options of `std_out` but the output will be write\r\non *STDERR* instead or *STDOUT*.\r\n\r\n```bash\r\nstd_err \"STDERR write\"\r\n```\r\n\r\n### std_in\r\n\r\nUsing `std_in` you have a lot of options already available on `read` build-in\r\ncommand, but there are some other helpful things you also can use.\r\nIn first the last input is stored on `STDIN` Bash variable, so, after you use\r\n`std_in` you can get the value by calling `$STDIN`.\r\n\r\n#### Input\r\n\r\n```bash\r\nstd_in \"Input\"\r\n```\r\n\r\nDoes not looks so better, but you can use the same styles you use on `std_out`\r\nfunction to stylize the message.\r\n\r\n#### Required input\r\n\r\nIt will not stop until you provide a value.\r\n\r\n```bash\r\nstd_in -q \"Input required\"\r\n```\r\n\r\n#### Using readline\r\n\r\nYou can use readline as well as `read` build-in does.\r\n\r\n```bash\r\nstd_in -e \"Input using readline\"\r\n```\r\n\r\n#### Defining a delimiter\r\n\r\nYou can define a delimiter as well as `read` build-in does.\r\n\r\n```bash\r\nstd_in -d . \"Input with delimiter \\\".\\\"\"\r\n```\r\n\r\n#### Defining a timeout\r\n\r\nYou can define a timeout as well as `read` build-in does.\r\n\r\n```bash\r\nstd_in -t 2 \"Input with timeout of 2 seconds\"\r\n```\r\n\r\n#### Defining a limit of chars\r\n\r\nYou can define a limit of chars as well as `read` build-in does.\r\n\r\n```bash\r\nstd_in -n 4 \"Input with with limit of 4 chars\"\r\n```\r\n\r\n#### Defining a preload\r\n\r\nYou can define a preload (default value) as well as `read` build-in does.\r\n\r\n```bash\r\nstd_in -i \"Preload\" \"Input with with a preload\"\r\n```\r\n\r\n#### Custom prompt\r\n\r\nBy default, `std_in` uses `: ` as prompt, but you can customize it.\r\n\r\n```bash\r\nstd_in -p \"\\n]> \" \"Input with custom prompt\"\r\n```\r\n\r\n[std_out]: #std_out\r\n[std_err]: #std_err\r\n[std_in]: #std_in\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}